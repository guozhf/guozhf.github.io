---
layout: default
title: 并发
parent: Java
has_children: true
nav_order: 1
---

# 并发

## 为什么并发？

1. **资源利用率** 

在某些情况下，程序必须等待某个外部操作执行完成，例如IO，而在等待时程序无法执行其他任何工作。因此，如果在等待的同时可以运行另一个程序，那么无疑将会提高资源的利用率。

2. **公平性**

不同的用户和程序对计算机上的资源有着同等的使用权。计算机一般使用时间片轮转来给这些用户和程序共享资源，而不是串行的，执行完一个再执行另一个。

3. **便利性**

通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在有必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。


一个对象是否需要是线程安全的，取决于它是否被多个线程访问。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式。

在线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致(或者说某个类的行为和我们预期的完全一致)。

原子性

操作只有一步，不可再细分，++count不是原子操作，++count相当于 count = count + 1，分成三步，第一步读取count的值，第二步count + 1， 第三步将结果写入count。

竞态条件

比如两个线程同时执++count，由于这个操作不是原子操作，所以两个线程可能同时读到count，然后执行+1操作，这样我们最后读到的count只增加了1，而不是2。这时候两个线程呈现出一种你追我赶的态势，并且有时候会同时执行操作。在并发编程中，这种由于不恰当的执行时序而出现不正确的结果的情况，就叫做竞态条件。当某个计算的正确性取决于多个线程的交替执行时序时，那么就会产生竞态条件。换句话说，就是正确的结果要取决于运气。

竞态条件的本质是——基于一种可能失效的观察结果来做出判断或者执行某个计算。因为我们的观察可能立马就会失效，比如我们读到count后，以为count=1，然后就执行count+1操作，实际上，可能当我们读完后要执行+1操作的时候，另一个线程已经将它+1了，而当前线程却浑然不知。这些问题都是执行时序导致的。

我们再举个常见的例子，单例模式中的竞态条件。
```JAVA
public class LazyInitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```
在开发中，有些对象的创建非常昂贵，我们想要在使用它时才创建，而不是早早的就创建它。于是有了上面的getInstance()方法，在获取对象实例时，先判断是否已经有了，有了就不创建了，没有则创建。在单线程中，这完全没有问题，但是在多线程环境中，结果将变得难以预料。假设有两个线程A,B同时需要获取ExpensiveObject的实例，于是调用了getInstance()，A调用的时候判断对象为空，则创建了对象，而与此同时B判断instance是否为空，则取决于不可预测的时序，这包括线程的调度方式，A需要花多长时间来初始化ExpensiveObject并且设置给instance。所以存在一种情况，那就是A还没有创建完成对象的时候，B就进入getInstance方法，并且得知想要的对象没有创建，于是也创建了一个ExpensiveObject，这样两次调用返回了不同的对象。本意上我们希望getInstance总是返回一个相同的对象，结果却事与愿违，这一切都因为存在竞态条件。

复合操作

count++就是复合操作，也就是这种操作时可以再分的，由原子操作组成的。这种操作就会产生竞态条件，而原子操作则不会，因为原子操作只有一步不可再细分。那么，如果避免竞态条件好像已经变得很明确，那就是将复合操作转变成“原子操作”。这里的“原子操作”不是指只有一步的操作，而是这一系列的操作必须由当前线程一起执行，执行完毕以后其他的线程才能进入执行。这就好像将复合操作包装起来一样，让他看起来像个原子操作。Java中实现这种机制的方法是通过加锁，或者使用线程安全类(原理应该也是加锁，带确认)。

内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)，由两部分组成，应该是作为锁的对象引用，一个作为有这个锁保护的代码块，如下；
```java
synchronized(lock) {
    // 访问或修改由锁保护的共享状态
}
```
每个Java对象都可以作为一个实现同步的锁，这些锁被称为内置锁(Intrinsic Lock)或监视器锁(Monitor Lock)。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。或者内置锁的唯一途径就是进入由这个锁保护的同步代码块或者方法。

Java的内置锁是互斥锁，这意味着最多只有一个线程能够持有这种锁。或者说被所保护的代码同时只允许一个线程访问。因此，由这个锁保护的同步代码块就会以原子方式执行，多个线程在执行该代码块时互不干扰。这确保了线程操作的安全，避免了竞态条件的产生，但是同步代码块或者方法每次只允许一个线程访问，如果是Servlet的话，服务的响应性将会变得非常低，令人难以接受。但这是一个性能问题，而不是线程安全问题。

重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。什么意思那？一个线程执行完同步代码块或者方法的时候不是会释放锁吗，释放了以后就不持有锁了，怎么还说要试图获取一个已经由自己持有的锁那？

实际上，**重入**并不是指上边讲的那样，而是子类重写了父类的syncronized方法，并且在方法内部调用了父类的方法。当子类调用自己的方法的时候，获取当前对象的内置锁，然后调用父类的方法，父类和子类实际上是同一把锁，在调用父类的方法的时候也要获取锁的。由于内置锁是可重入的，由于当前线程之前已经获取锁了，所以直接重入了。内置锁如果不是可重入的，那么调用父类方法的时候会停下来，因为子类还持有锁，所以将产生死锁。
同一个线程在调用本类中其他 synchronized 方法/块或父类中的 synchronized 方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。
代码如下；
```java
public class Widget {
    public synchronized void doSomething() {

    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(....);
        super.doSomething();
    }
}

```
那么，内置锁的重入是如何实现的那？

重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应的递减。当计数值为0时，这个锁将被释放。

每个对象都有一个内置锁，只是为了免去显式地创建锁对象。

并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。


---

**要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要进行正确的管理。**
以上介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，或者说串行的访问“临界区”资源。接下来介绍如何共享和发布对象，从而使他们能够安全地由多个线程同时访问。

根据上面对同步以及内置锁的介绍，我们知道使用内置锁可以实现原子性操作。不过，同步不止于此，它还有另一个重要的方面，**内存可见性(Memory Visibility)**。我们不仅要防止竞态条件的产生，而且希望确保当一个线程修改了对象状态后，其他线程能够立刻观察到状态的变化。

可见性

在单线程环境中，我们修改某个变量的值是完全没有问题的，我们总能读到正确的值。但是在多线程环境下，情况就变得复杂了，当读操作和写操作在不同的线程中时，我们没法确定在执行读操作时，变量的值是否已经被写操作修改了。也就是说线程只能看到变量的初始值，即使后来被改变了，但是它全然不知。这和竞态条件一样，都会使最终的结果产生偏差。

我们总结一下什么是可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

那么如何确保可见性那？为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。


